<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>nids API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nids</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from scapy.all import sniff, IP, TCP, Raw
from collections import defaultdict
import time
import threading
import logging
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Basic logging configuration to record events in &#39;nids.log&#39;
logging.basicConfig(filename=&#39;nids.log&#39;, level=logging.INFO)

# Dictionary to store packet counts per minute for each IP
packet_counts = defaultdict(lambda: defaultdict(int))
# Dictionary to track SYN packets
syn_packets = defaultdict(list)

# Store triggered alerts to avoid repetitive alerts
alerts_triggered = defaultdict(bool)

def send_alert(ip, count, alert_type, details):
    &#34;&#34;&#34;
    Send an alert via email.

    :param ip: IP address that triggered the alert
    :type ip: str
    :param count: Packet count
    :type count: int
    :param alert_type: Type of alert
    :type alert_type: str
    :param details: Detailed message for the alert
    :type details: str
    &#34;&#34;&#34;
    msg = MIMEMultipart()
    msg[&#39;From&#39;] = os.getenv(&#39;EMAIL_EXPEDIT&#39;)
    msg[&#39;To&#39;] = &#39;example@gmail.com&#39;  # Change based on who is testing, otherwise create a common one
    msg[&#39;Subject&#39;] = &#39;ALERTE NIDS&#39;

    body = f&#34;{alert_type}:\n{details}&#34;
    msg.attach(MIMEText(body, &#39;plain&#39;))

    smtp_server = &#39;smtp.gmail.com&#39;
    smtp_port = 587  # Gmail port for SMTP TLS

    try:
        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.starttls()
            server.login(os.getenv(&#39;EMAIL_EXPEDIT&#39;), os.getenv(&#39;EMAIL_PASS&#39;))
            server.send_message(msg)
            print(f&#34;Alerte envoyée à {msg[&#39;To&#39;]} pour {ip}&#34;)
    except Exception as e:
        print(f&#34;Erreur lors de l&#39;envoi de l&#39;alerte : {e}&#34;)

def log_event(event):
    &#34;&#34;&#34;
    Log an event with the current time.

    :param event: Event description
    :type event: str
    &#34;&#34;&#34;
    logging.info(f&#39;{time.ctime()}: {event}&#39;)

def signature_based_detection(packet):
    &#34;&#34;&#34;
    Perform signature-based detection on the packet.

    :param packet: Network packet
    :type packet: scapy.packet.Packet
    &#34;&#34;&#34;
    if packet.haslayer(TCP):
        if packet[TCP].dport == 22:  # Example: SSH connection detection
            alert_message = f&#39;Tentative de connexion SSH détectée depuis {packet[IP].src}&#39;
            print(f&#39;ALERTE: {alert_message}&#39;)
            log_event(alert_message)
            #send_alert(packet[IP].src, 1, &#34;Tentative de connexion SSH&#34;, alert_message)  # Send alert with the appropriate type

def detect_fuzzing(packet):
    &#34;&#34;&#34;
    Detect suspicious payloads (fuzzing).

    :param packet: Network packet
    :type packet: scapy.packet.Packet
    &#34;&#34;&#34;
    if IP in packet and TCP in packet:
        ip_layer = packet[IP]
        tcp_layer = packet[TCP]

        if Raw in packet:
            payload = packet[Raw].load
            payload_length = len(payload)

            if payload_length &gt; 1000:
                alert_message = (
                    f&#34;Paquet avec charge utile suspecte (grande taille) détecté : &#34;
                    f&#34;{ip_layer.src}:{tcp_layer.sport} -&gt; {ip_layer.dst}:{tcp_layer.dport}, Taille: {payload_length}&#34;
                )
                print(f&#39;ALERTE: {alert_message}&#39;)
                log_event(alert_message)
                #send_alert(ip_layer.src, payload_length, &#34;Charge utile suspecte (grande taille)&#34;, alert_message)

            unique_bytes = set(payload)
            if len(unique_bytes) == 1:
                alert_message = (
                    f&#34;Paquet avec charge utile répétitive détecté : &#34;
                    f&#34;{ip_layer.src}:{tcp_layer.sport} -&gt; {ip_layer.dst}:{tcp_layer.dport}, Contenu: {payload[:50]}...&#34;
                )
                print(f&#39;ALERTE: {alert_message}&#39;)
                log_event(alert_message)
                #send_alert(ip_layer.src, payload_length, &#34;Charge utile répétitive&#34;, alert_message)
            elif payload_length &gt; 50:
                repeated_pattern = False
                for i in range(1, 11):
                    pattern = payload[:i]
                    if pattern * (payload_length // i) == payload[:i * (payload_length // i)]:
                        repeated_pattern = True
                        break
                if repeated_pattern:
                    alert_message = (
                        f&#34;Paquet avec motif répétitif détecté : &#34;
                        f&#34;{ip_layer.src}:{tcp_layer.sport} -&gt; {ip_layer.dst}:{tcp_layer.dport}, Contenu: {payload[:50]}...&#34;
                    )
                    print(f&#39;ALERTE: {alert_message}&#39;)
                    log_event(alert_message)
                    #send_alert(ip_layer.src, payload_length, &#34;Motif répétitif détecté&#34;, alert_message)

def detect_syn_scan(packet):
    &#34;&#34;&#34;
    Add or remove a SYN packet from the dictionary based on whether it received a SYN/ACK or not.

    :param packet: Network packet
    :type packet: scapy.packet.Packet
    &#34;&#34;&#34;
    if packet.haslayer(IP):
        ip_layer = packet[IP]
        
        if packet.haslayer(TCP):
            tcp_layer = packet[TCP]
            
            if tcp_layer.flags == &#39;S&#39;:  # SYN flag is set
                syn_packets[(ip_layer.src, ip_layer.dst, tcp_layer.sport, tcp_layer.dport)].append(time.time())
                return
            
            if tcp_layer.flags == &#39;SA&#39;:  # SYN/ACK flag is set
                if (ip_layer.dst, ip_layer.src, tcp_layer.dport, tcp_layer.sport) in syn_packets:
                    syn_packets[(ip_layer.dst, ip_layer.src, tcp_layer.dport, tcp_layer.sport)].clear()
                return

def check_syn_packets():
    &#34;&#34;&#34;
    Determine if a SYN packet received a response within 5 seconds.
    &#34;&#34;&#34;
    while True:
        current_time = time.time()
        for key, timestamps in list(syn_packets.items()):
            if timestamps and current_time - timestamps[0] &gt; 5:
                src_ip, dst_ip, src_port, dst_port = key
                print(f&#34;Possible SYN scan detected from {src_ip}:{src_port} to {dst_ip}:{dst_port}&#34;)
                del syn_packets[key]
        #time.sleep(1)  # Check every second

def packet_handler(packet):
    &#34;&#34;&#34;
    Handle incoming packets, update counts, and perform detections.

    :param packet: Network packet
    :type packet: scapy.packet.Packet
    &#34;&#34;&#34;
    if packet.haslayer(IP):
        src_ip = packet[IP].src
        current_minute = int(time.time() // 60)
        packet_counts[src_ip][current_minute] += 1
        signature_based_detection(packet)
        detect_fuzzing(packet)

def calculate_average_packets_per_minute():
    &#34;&#34;&#34;
    Calculate and return the average number of packets per minute for each IP.

    :return: Dictionary of IP addresses and their average packets per minute
    :rtype: dict
    &#34;&#34;&#34;
    ip_statistics = {}
    for ip, counts in packet_counts.items():
        total_packets = sum(counts.values())
        total_minutes = len(counts)
        average_packets_per_minute = total_packets / total_minutes if total_minutes &gt; 0 else 0
        ip_statistics[ip] = average_packets_per_minute
    return ip_statistics

def check_and_alert():
    &#34;&#34;&#34;
    Periodically check packet counts and trigger alerts if thresholds are exceeded.
    &#34;&#34;&#34;
    while True:
        time.sleep(60)  # Wait one minute before checking
        current_minute = int(time.time() // 60)

        for ip in packet_counts.keys():
            if current_minute &lt;= 1:
                continue

            total_packets = sum(packet_counts[ip].values())
            total_minutes = len(packet_counts[ip]) - 1  # Exclude the current minute
            average_packets_per_minute = total_packets / total_minutes if total_minutes &gt; 0 else 0

            if packet_counts[ip][current_minute - 1] &gt; 100 and not alerts_triggered[ip]:
                alert_message = (
                    f&#34;L&#39;IP {ip} a dépassé 100 paquets par minute avec &#34;
                    f&#34;{packet_counts[ip][current_minute - 1]} paquets à la minute {current_minute - 1}.&#34;
                )
                print(f&#39;ALERTE: {alert_message}&#39;)
                log_event(alert_message)
                #send_alert(ip, packet_counts[ip][current_minute - 1], &#34;Dépassement de seuil de paquets par minute&#34;, alert_message)
                alerts_triggered[ip] = True

def main():
    &#34;&#34;&#34;
    Main function to start packet capture and alert checking.
    &#34;&#34;&#34;
    alert_thread = threading.Thread(target=check_and_alert)
    alert_thread.daemon = True
    alert_thread.start()

    syn_thread = threading.Thread(target=check_syn_packets, daemon=True)
    syn_thread.start()

    sniff(prn=packet_handler, timeout=600)

    ip_stats = calculate_average_packets_per_minute()
    for ip, avg_packets in ip_stats.items():
        print(f&#39;IP {ip}: Nombre moyen de paquets par minute: {avg_packets:.2f}&#39;)
        
# Exécuter le script principal si ce fichier est exécuté directement
if __name__ == &#39;__main__&#39;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="nids.calculate_average_packets_per_minute"><code class="name flex">
<span>def <span class="ident">calculate_average_packets_per_minute</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate and return the average number of packets per minute for each IP.</p>
<p>:return: Dictionary of IP addresses and their average packets per minute
:rtype: dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_average_packets_per_minute():
    &#34;&#34;&#34;
    Calculate and return the average number of packets per minute for each IP.

    :return: Dictionary of IP addresses and their average packets per minute
    :rtype: dict
    &#34;&#34;&#34;
    ip_statistics = {}
    for ip, counts in packet_counts.items():
        total_packets = sum(counts.values())
        total_minutes = len(counts)
        average_packets_per_minute = total_packets / total_minutes if total_minutes &gt; 0 else 0
        ip_statistics[ip] = average_packets_per_minute
    return ip_statistics</code></pre>
</details>
</dd>
<dt id="nids.check_and_alert"><code class="name flex">
<span>def <span class="ident">check_and_alert</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Periodically check packet counts and trigger alerts if thresholds are exceeded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_and_alert():
    &#34;&#34;&#34;
    Periodically check packet counts and trigger alerts if thresholds are exceeded.
    &#34;&#34;&#34;
    while True:
        time.sleep(60)  # Wait one minute before checking
        current_minute = int(time.time() // 60)

        for ip in packet_counts.keys():
            if current_minute &lt;= 1:
                continue

            total_packets = sum(packet_counts[ip].values())
            total_minutes = len(packet_counts[ip]) - 1  # Exclude the current minute
            average_packets_per_minute = total_packets / total_minutes if total_minutes &gt; 0 else 0

            if packet_counts[ip][current_minute - 1] &gt; 100 and not alerts_triggered[ip]:
                alert_message = (
                    f&#34;L&#39;IP {ip} a dépassé 100 paquets par minute avec &#34;
                    f&#34;{packet_counts[ip][current_minute - 1]} paquets à la minute {current_minute - 1}.&#34;
                )
                print(f&#39;ALERTE: {alert_message}&#39;)
                log_event(alert_message)
                #send_alert(ip, packet_counts[ip][current_minute - 1], &#34;Dépassement de seuil de paquets par minute&#34;, alert_message)
                alerts_triggered[ip] = True</code></pre>
</details>
</dd>
<dt id="nids.check_syn_packets"><code class="name flex">
<span>def <span class="ident">check_syn_packets</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine if a SYN packet received a response within 5 seconds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_syn_packets():
    &#34;&#34;&#34;
    Determine if a SYN packet received a response within 5 seconds.
    &#34;&#34;&#34;
    while True:
        current_time = time.time()
        for key, timestamps in list(syn_packets.items()):
            if timestamps and current_time - timestamps[0] &gt; 5:
                src_ip, dst_ip, src_port, dst_port = key
                print(f&#34;Possible SYN scan detected from {src_ip}:{src_port} to {dst_ip}:{dst_port}&#34;)
                del syn_packets[key]
        #time.sleep(1)  # Check every second</code></pre>
</details>
</dd>
<dt id="nids.detect_fuzzing"><code class="name flex">
<span>def <span class="ident">detect_fuzzing</span></span>(<span>packet)</span>
</code></dt>
<dd>
<div class="desc"><p>Detect suspicious payloads (fuzzing).</p>
<p>:param packet: Network packet
:type packet: scapy.packet.Packet</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detect_fuzzing(packet):
    &#34;&#34;&#34;
    Detect suspicious payloads (fuzzing).

    :param packet: Network packet
    :type packet: scapy.packet.Packet
    &#34;&#34;&#34;
    if IP in packet and TCP in packet:
        ip_layer = packet[IP]
        tcp_layer = packet[TCP]

        if Raw in packet:
            payload = packet[Raw].load
            payload_length = len(payload)

            if payload_length &gt; 1000:
                alert_message = (
                    f&#34;Paquet avec charge utile suspecte (grande taille) détecté : &#34;
                    f&#34;{ip_layer.src}:{tcp_layer.sport} -&gt; {ip_layer.dst}:{tcp_layer.dport}, Taille: {payload_length}&#34;
                )
                print(f&#39;ALERTE: {alert_message}&#39;)
                log_event(alert_message)
                #send_alert(ip_layer.src, payload_length, &#34;Charge utile suspecte (grande taille)&#34;, alert_message)

            unique_bytes = set(payload)
            if len(unique_bytes) == 1:
                alert_message = (
                    f&#34;Paquet avec charge utile répétitive détecté : &#34;
                    f&#34;{ip_layer.src}:{tcp_layer.sport} -&gt; {ip_layer.dst}:{tcp_layer.dport}, Contenu: {payload[:50]}...&#34;
                )
                print(f&#39;ALERTE: {alert_message}&#39;)
                log_event(alert_message)
                #send_alert(ip_layer.src, payload_length, &#34;Charge utile répétitive&#34;, alert_message)
            elif payload_length &gt; 50:
                repeated_pattern = False
                for i in range(1, 11):
                    pattern = payload[:i]
                    if pattern * (payload_length // i) == payload[:i * (payload_length // i)]:
                        repeated_pattern = True
                        break
                if repeated_pattern:
                    alert_message = (
                        f&#34;Paquet avec motif répétitif détecté : &#34;
                        f&#34;{ip_layer.src}:{tcp_layer.sport} -&gt; {ip_layer.dst}:{tcp_layer.dport}, Contenu: {payload[:50]}...&#34;
                    )
                    print(f&#39;ALERTE: {alert_message}&#39;)
                    log_event(alert_message)
                    #send_alert(ip_layer.src, payload_length, &#34;Motif répétitif détecté&#34;, alert_message)</code></pre>
</details>
</dd>
<dt id="nids.detect_syn_scan"><code class="name flex">
<span>def <span class="ident">detect_syn_scan</span></span>(<span>packet)</span>
</code></dt>
<dd>
<div class="desc"><p>Add or remove a SYN packet from the dictionary based on whether it received a SYN/ACK or not.</p>
<p>:param packet: Network packet
:type packet: scapy.packet.Packet</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detect_syn_scan(packet):
    &#34;&#34;&#34;
    Add or remove a SYN packet from the dictionary based on whether it received a SYN/ACK or not.

    :param packet: Network packet
    :type packet: scapy.packet.Packet
    &#34;&#34;&#34;
    if packet.haslayer(IP):
        ip_layer = packet[IP]
        
        if packet.haslayer(TCP):
            tcp_layer = packet[TCP]
            
            if tcp_layer.flags == &#39;S&#39;:  # SYN flag is set
                syn_packets[(ip_layer.src, ip_layer.dst, tcp_layer.sport, tcp_layer.dport)].append(time.time())
                return
            
            if tcp_layer.flags == &#39;SA&#39;:  # SYN/ACK flag is set
                if (ip_layer.dst, ip_layer.src, tcp_layer.dport, tcp_layer.sport) in syn_packets:
                    syn_packets[(ip_layer.dst, ip_layer.src, tcp_layer.dport, tcp_layer.sport)].clear()
                return</code></pre>
</details>
</dd>
<dt id="nids.log_event"><code class="name flex">
<span>def <span class="ident">log_event</span></span>(<span>event)</span>
</code></dt>
<dd>
<div class="desc"><p>Log an event with the current time.</p>
<p>:param event: Event description
:type event: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_event(event):
    &#34;&#34;&#34;
    Log an event with the current time.

    :param event: Event description
    :type event: str
    &#34;&#34;&#34;
    logging.info(f&#39;{time.ctime()}: {event}&#39;)</code></pre>
</details>
</dd>
<dt id="nids.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Main function to start packet capture and alert checking.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    &#34;&#34;&#34;
    Main function to start packet capture and alert checking.
    &#34;&#34;&#34;
    alert_thread = threading.Thread(target=check_and_alert)
    alert_thread.daemon = True
    alert_thread.start()

    syn_thread = threading.Thread(target=check_syn_packets, daemon=True)
    syn_thread.start()

    sniff(prn=packet_handler, timeout=600)

    ip_stats = calculate_average_packets_per_minute()
    for ip, avg_packets in ip_stats.items():
        print(f&#39;IP {ip}: Nombre moyen de paquets par minute: {avg_packets:.2f}&#39;)</code></pre>
</details>
</dd>
<dt id="nids.packet_handler"><code class="name flex">
<span>def <span class="ident">packet_handler</span></span>(<span>packet)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle incoming packets, update counts, and perform detections.</p>
<p>:param packet: Network packet
:type packet: scapy.packet.Packet</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def packet_handler(packet):
    &#34;&#34;&#34;
    Handle incoming packets, update counts, and perform detections.

    :param packet: Network packet
    :type packet: scapy.packet.Packet
    &#34;&#34;&#34;
    if packet.haslayer(IP):
        src_ip = packet[IP].src
        current_minute = int(time.time() // 60)
        packet_counts[src_ip][current_minute] += 1
        signature_based_detection(packet)
        detect_fuzzing(packet)</code></pre>
</details>
</dd>
<dt id="nids.send_alert"><code class="name flex">
<span>def <span class="ident">send_alert</span></span>(<span>ip, count, alert_type, details)</span>
</code></dt>
<dd>
<div class="desc"><p>Send an alert via email.</p>
<p>:param ip: IP address that triggered the alert
:type ip: str
:param count: Packet count
:type count: int
:param alert_type: Type of alert
:type alert_type: str
:param details: Detailed message for the alert
:type details: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_alert(ip, count, alert_type, details):
    &#34;&#34;&#34;
    Send an alert via email.

    :param ip: IP address that triggered the alert
    :type ip: str
    :param count: Packet count
    :type count: int
    :param alert_type: Type of alert
    :type alert_type: str
    :param details: Detailed message for the alert
    :type details: str
    &#34;&#34;&#34;
    msg = MIMEMultipart()
    msg[&#39;From&#39;] = os.getenv(&#39;EMAIL_EXPEDIT&#39;)
    msg[&#39;To&#39;] = &#39;example@gmail.com&#39;  # Change based on who is testing, otherwise create a common one
    msg[&#39;Subject&#39;] = &#39;ALERTE NIDS&#39;

    body = f&#34;{alert_type}:\n{details}&#34;
    msg.attach(MIMEText(body, &#39;plain&#39;))

    smtp_server = &#39;smtp.gmail.com&#39;
    smtp_port = 587  # Gmail port for SMTP TLS

    try:
        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.starttls()
            server.login(os.getenv(&#39;EMAIL_EXPEDIT&#39;), os.getenv(&#39;EMAIL_PASS&#39;))
            server.send_message(msg)
            print(f&#34;Alerte envoyée à {msg[&#39;To&#39;]} pour {ip}&#34;)
    except Exception as e:
        print(f&#34;Erreur lors de l&#39;envoi de l&#39;alerte : {e}&#34;)</code></pre>
</details>
</dd>
<dt id="nids.signature_based_detection"><code class="name flex">
<span>def <span class="ident">signature_based_detection</span></span>(<span>packet)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform signature-based detection on the packet.</p>
<p>:param packet: Network packet
:type packet: scapy.packet.Packet</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signature_based_detection(packet):
    &#34;&#34;&#34;
    Perform signature-based detection on the packet.

    :param packet: Network packet
    :type packet: scapy.packet.Packet
    &#34;&#34;&#34;
    if packet.haslayer(TCP):
        if packet[TCP].dport == 22:  # Example: SSH connection detection
            alert_message = f&#39;Tentative de connexion SSH détectée depuis {packet[IP].src}&#39;
            print(f&#39;ALERTE: {alert_message}&#39;)
            log_event(alert_message)
            #send_alert(packet[IP].src, 1, &#34;Tentative de connexion SSH&#34;, alert_message)  # Send alert with the appropriate type</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="nids.calculate_average_packets_per_minute" href="#nids.calculate_average_packets_per_minute">calculate_average_packets_per_minute</a></code></li>
<li><code><a title="nids.check_and_alert" href="#nids.check_and_alert">check_and_alert</a></code></li>
<li><code><a title="nids.check_syn_packets" href="#nids.check_syn_packets">check_syn_packets</a></code></li>
<li><code><a title="nids.detect_fuzzing" href="#nids.detect_fuzzing">detect_fuzzing</a></code></li>
<li><code><a title="nids.detect_syn_scan" href="#nids.detect_syn_scan">detect_syn_scan</a></code></li>
<li><code><a title="nids.log_event" href="#nids.log_event">log_event</a></code></li>
<li><code><a title="nids.main" href="#nids.main">main</a></code></li>
<li><code><a title="nids.packet_handler" href="#nids.packet_handler">packet_handler</a></code></li>
<li><code><a title="nids.send_alert" href="#nids.send_alert">send_alert</a></code></li>
<li><code><a title="nids.signature_based_detection" href="#nids.signature_based_detection">signature_based_detection</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>